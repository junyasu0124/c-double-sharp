import { BaseToken } from "../main";
import { SyntaxError, UnhandledError, isNext, isMethodKeyword, operators, removeEmptyWords, isExprKeyword, convertBlock, converted, indentCount, assignmentOperators, decorations, changeKind } from "../convert";
import { convertSwitch } from "./switch";
import { Type, convertType, parseFunctionType, parseType } from "./typeAndVariable";

export { convertRightSide, noSpacesOperators, withSpacesOperators, noLeftSpacesRightSpaceOperators, leftSpaceNoRightSpacesOperators };


const lambdaInputConnectOperators = new Set(['.', ',', '(', ')', '?', ':', '-', '/', '=>', '~', '#', '::']);
const noSpacesOperators = new Set(['.', '(', ')', '<', '>', '[', ']', '++', '--', '!', '?.', '!.', '::', '@', '$']);
const withSpacesOperators = new Set(['?', ':', '=', '+', '+=', '-', '-=', '*', '*=', '/', '/=', '%', '%=', '??', '??=', '<<', '<<=', '>>', '>>=', '>>>', '>>>=', '&', '&=', '^', '^=', '|', '|=', '==', '!=', '<=', '>=', '<', '>', '&&', '||', '=>', ':']);
const noLeftSpacesRightSpaceOperators = new Set([',', ';', '{']);
const leftSpaceNoRightSpacesOperators = new Set(['}']);
const fnNames = new Set(['FunctionName', 'Fn1', 'Fn2']);
/**
 * 
 * @param tokens 
 * @param insertIndex 自動生成の関数を挿入するconvertedにおけるインデックス
 * @param assigningVar 変数に代入する形式であるかどうか、代入する場合は{ name: 変数の名前, type: trueならば型推論可能、そうでない場合は変数の型 }、代入しない場合はnull
 * @param shouldStatic convertSwitchで自動生成される関数をstaticにする必要があるかどうか
 * @param indentLevel
 * @returns convertSwitchによって自動生成された関数の挿入位置、自動生成されなかった場合はfalse
 */
function convertRightSide(tokens: BaseToken[], insertIndex: number, assigningType: null | true | Type, shouldStatic: boolean, indentLevel: number): {
  endAt: number;
  isConst: boolean;
  insertedAutoGeneratedFn: { start: number, end: number }[] | false;
} {
  let lastBoundaryIndex = converted.length;
  let lastBoundaryToken: BaseToken | null = tokens[0];
  let setLastBoundaryTokenNext = false;
  let isConst = true;
  let insertedAutoGeneratedFn: { start: number, end: number }[] | false = false;
  const spaceIndexes: Set<number> = new Set();

  let endAt = parseExpr(tokens, false, false);
  if (converted[converted.length - 1] !== ';') {
    converted.push(';\r\n');
  }

  const spaceIndexesArray = Array.from(spaceIndexes);
  spaceIndexesArray.sort((a, b) => a - b);
  for (let i = spaceIndexesArray.length - 1; i >= 0; i--) {
    const index = spaceIndexesArray[i];
    if (index === 0)
      continue;
    converted.splice(index, 0, ' ');
  }

  return { endAt, isConst, insertedAutoGeneratedFn };

  function parseExpr(tokens: BaseToken[], isInArgs = false, earlyReturn = false): number {
    const initialConvertedLength = converted.length;
    let initialBoundaryToken: BaseToken | null = null;
    let isInTuple: false | BaseToken = false; // タプルのときはタプルの最初のトークン
    let isAsync = false;
    let isAfterFn = 0;
    let afterFnIndex = 0;
    let isTernaryOperator = false;
    let currentIsSpace = false;
    let previousIsSpace = false;
    let currentMethod = false;
    let previousMethod = false;

    for (let i = 0; i < tokens.length; i++) {
      const current = tokens[i];

      previousIsSpace = currentIsSpace;

      if (current.category === 'space') {
        currentIsSpace = true;
        if (tokens.length > i + 1 && (tokens[i + 1].category === undefined || tokens[i + 1].category === 'keyword' || tokens[i + 1].category === 'context_keyword'))
          spaceIndexes.add(converted.length);
        continue;
      } else {
        currentIsSpace = false;
      }

      if (current.category === 'line_break') {
        if (tokens.length > i + 1 && (tokens[i + 1].category === undefined || tokens[i + 1].category === 'keyword' || tokens[i + 1].category === 'context_keyword'))
          spaceIndexes.add(converted.length);
        continue;
      }

      if (current.category === 'comment') {
        continue;
      }

      if (setLastBoundaryTokenNext) {
        lastBoundaryToken = current;
        setLastBoundaryTokenNext = false;
        if (initialBoundaryToken === null)
          initialBoundaryToken = current;
      }

      previousMethod = currentMethod;
      currentMethod = false;

      isAfterFn--;
      if (current.text === ';' || current.text === ',' || current.text === '{' || current.text === '}' || assignmentOperators.has(current.text)) {
        lastBoundaryToken = null;
        setLastBoundaryTokenNext = true;
        if (current.text === ',' && isInArgs === false && previousMethod === false) {
          if (isInTuple !== false) {
            converted.push(')');
            isInTuple = false;
          }
          converted.push(',');
          spaceIndexes.add(converted.length);
          lastBoundaryIndex = converted.length;
          continue;
        }
        if (isInTuple !== false) {
          if (converted[converted.length - 1] === ',') {
            converted.pop();
          }
          converted.push(')');

          let previousToken = tokens[i - 1];
          for (let j = i - 1; j >= 0; j--) {
            if (tokens[j].category !== 'space' && tokens[j].category !== 'line_break' && tokens[j].category !== 'comment') {
              previousToken = tokens[j];
              break;
            }
          }
          decorations.push({ start: isInTuple.start, end: previousToken.end, kind: 'tuple' });
        }
        lastBoundaryIndex = converted.length;
        if (current.text !== ';' && current.text !== ',')
          return i - 1;
        return i;
      } else if (isMethodKeyword(current.kind) || isExprKeyword(current.kind) || fnNames.has(current.text)) {
        const originalI = i;
        let nextToBlockOrMethod;
        if (current.text === 'default' && isNext(token => token.category === undefined || token.category === 'context_keyword' || token.text === '(', true, i, tokens) === false) {
          converted.push('default');
          lastBoundaryIndex = converted.length - 1;
          lastBoundaryToken = current;
        } else if (current.kind === 'keyword.block-or-method' && (nextToBlockOrMethod = isNext(token => token.text === ';' || token.text === '{', true, i, tokens, false, true) as { result: boolean, index: number }, nextToBlockOrMethod.result)) {
          throw new SyntaxError(tokens[nextToBlockOrMethod.index]);
        } else {
          if (current.kind !== 'keyword.block-or-method')
            isConst = false;
          currentMethod = true;
          const isMethod = isMethodKeyword(current.kind) || fnNames.has(current.text);
          if (fnNames.has(current.text))
            changeKind(current, 'name.fn', true);
          let fnStartIndex = converted.length;
          converted.push(current.text);
          if (isMethod)
            converted.push('(');
          else
            converted.push(' ');
          lastBoundaryIndex = converted.length;
          lastBoundaryToken = null;
          setLastBoundaryTokenNext = true;
          const firstArgIndex = isNext(() => true, true, i, tokens, false, true) as { result: boolean, index: number };
          if (firstArgIndex.index === -1)
            throw new SyntaxError(tokens[i - 1]);
          i = firstArgIndex.index - 1;

          let argsEndToken: BaseToken | null = null;
          let pushPeriod = false;
          if (tokens[firstArgIndex.index].text === ';') {
            i = firstArgIndex.index;
            if (isMethod && earlyReturn === false && isNext(token => token.category === 'context_keyword' || token.category === undefined, false, firstArgIndex.index, tokens)) {
              converted.push(')', '.');
              pushPeriod = true;
            } else {
              if (isMethod)
                converted.push(')');
            }
          } else {
            while (true) {
              const parsed = parseExpr(tokens.slice(i + 1), true);
              i += parsed + 1;
              if (tokens.length <= i) {
                if (isMethod)
                  argsEndToken = tokens[tokens.length - 1];
                break;
              }
              if (parsed === -1)
                throw new UnhandledError(tokens[i]);
              pushPeriod = false;
              if (tokens[i].text === ',') {
                converted.push(',');
                spaceIndexes.add(converted.length);
                lastBoundaryIndex = converted.length;
                lastBoundaryToken = null;
                setLastBoundaryTokenNext = true;
              } else if (tokens[i].text === ';') {
                if (isMethod && earlyReturn === false && isNext(token => token.category === 'context_keyword' || token.category === undefined, false, i, tokens)) {
                  converted.push(')', '.');
                  pushPeriod = true;
                } else {
                  if (isMethod)
                    converted.push(')');
                }
                if (isMethod) {
                  let previous = tokens[i - 1];
                  for (let j = i - 1; j >= 0; j--) {
                    if (tokens[j].category !== 'space' && tokens[j].category !== 'line_break' && tokens[j].category !== 'comment') {
                      previous = tokens[j];
                      break;
                    }
                  }
                  argsEndToken = previous;
                }
                break;
              }
            }
          }

          if (argsEndToken !== null) {
            const nextToCurrent = isNext(() => true, true, originalI, tokens, true, false) as { result: boolean, item: BaseToken | null };
            if (nextToCurrent.item === null)
              throw new UnhandledError(tokens[originalI]);
            decorations.push({ start: nextToCurrent.item.start, end: argsEndToken.end, kind: 'fn-args' });
          }

          if (isInArgs && isNext(token => token.text !== ';' && token.text !== ',', true, i, tokens)) {
            converted.push(',');
            spaceIndexes.add(converted.length);
          }

          if (isInArgs === false && !pushPeriod) {
            isAfterFn = 1;
            afterFnIndex = i;
          }

          lastBoundaryIndex = fnStartIndex;
          let boundaryToken = isNext(() => true, true, i, tokens, true, false) as { result: boolean, item: BaseToken | null };
          lastBoundaryToken = boundaryToken.item;
        }
      } else if (current.text === '(') {
        const isNextTilde = isNext(token => token.text === '~', true, i, tokens, false, true) as { result: boolean, index: number };
        if (isNextTilde.result) {
          converted.push('(', '~');
          i = isNextTilde.index;
          lastBoundaryIndex = converted.length;
          lastBoundaryToken = null;
          setLastBoundaryTokenNext = true;
          continue;
        }
        let parenthesisCount = 1;
        for (let j = i + 1; j < tokens.length; j++) {
          if (tokens[j].text === '(') {
            parenthesisCount++;
          } else if (tokens[j].text === ')') {
            parenthesisCount--;
            if (parenthesisCount === 0) {
              const leftParenthesisIndexAtConverted = converted.length;
              const previousConvertedLength = converted.length;
              converted.push('(');
              lastBoundaryIndex = converted.length;
              lastBoundaryToken = null;
              setLastBoundaryTokenNext = true;
              i += parseExpr(tokens.slice(i + 1, j)) + 1;
              if (converted[leftParenthesisIndexAtConverted + 1] === '(' && converted[converted.length - 1] === ')') {
                shiftSpaceIndexes(leftParenthesisIndexAtConverted);
                converted.splice(leftParenthesisIndexAtConverted, 1);
              } else {
                converted.push(')');
              }
              lastBoundaryIndex = previousConvertedLength;
              const boundaryToken = isNext(() => true, true, i, tokens, true, false) as { result: boolean, item: BaseToken | null };
              lastBoundaryToken = boundaryToken.item;
              break;
            }
          }
        }
      } else if (current.text === '#') {
        isConst = false;
        if (tokens.length === i - 1) {
          converted.push('[', ']');
        } else if (isNext(token => token.category !== 'operator' || token.text === '++' || token.text === '--', true, i, tokens)) {
          const originalI = i;
          converted.push('[');
          lastBoundaryIndex = converted.length;
          lastBoundaryToken = null;
          setLastBoundaryTokenNext = true;
          let indexerEndToken: BaseToken | null = null;
          while (true) {
            i += parseExpr(tokens.slice(i + 1), false, true) + 1;
            if (tokens.length <= i) {
              indexerEndToken = tokens[tokens.length - 1];
              break;
            }
            if (tokens[i].text === ',') {
              converted.push(',');
              spaceIndexes.add(converted.length);
              lastBoundaryIndex = converted.length;
              lastBoundaryToken = null;
              setLastBoundaryTokenNext = true;
            } else if (tokens[i].text === ';') {
              if (earlyReturn === false && isNext(token => token.category === 'context_keyword' || token.category === undefined, false, i, tokens)) {
                converted.push(']', '.');
              } else {
                converted.push(']');
              }
              let previousToken = tokens[i - 1];
              for (let j = i - 1; j >= 0; j--) {
                if (tokens[j].category !== 'space' && tokens[j].category !== 'line_break' && tokens[j].category !== 'comment') {
                  previousToken = tokens[j];
                  break;
                }
              }
              indexerEndToken = previousToken;
              break;
            }
          }
          const nextToCurrent = isNext(() => true, true, originalI, tokens, true, false) as { result: boolean, item: BaseToken | null };
          if (nextToCurrent.item === null)
            throw new UnhandledError(tokens[originalI]);
          decorations.push({ start: nextToCurrent.item.start, end: indexerEndToken.end, kind: 'indexer' });

          if (isInArgs === false) {
            isAfterFn = 1;
            afterFnIndex = i;
          }
        } else {
          converted.push('[', ']');
        }
      } else if (current.text === '~') {
        isConst = false;
        if (isInTuple === false) {
          converted.splice(lastBoundaryIndex, 0, '(');
          if (isAsync === false)
            shiftSpaceIndexes(lastBoundaryIndex);
          isInTuple = lastBoundaryToken ?? tokens[i - 1];
        }
        converted.push(',');
        spaceIndexes.add(converted.length);
      } else if (current.text === '=>') {
        isConst = false;
        let parenthesesCount = 0;
        let isBroken = false;
        for (let j = i - 1; j >= 0; j--) {
          if (operators.has(tokens[j].text) && lambdaInputConnectOperators.has(tokens[j].text) === false && tokens[j].text !== 'async') {
            if (parenthesesCount === 0) {
              throw new UnhandledError(tokens[j], "What's happening?");
              shiftSpaceIndexes(j + 1);
              converted.splice(j + 1, 0, '(');
              lastBoundaryIndex = j + 1;


              if (isInTuple !== false) {
                if (converted[converted.length - 1] === ',') {
                  converted.pop();
                }
                converted.push(')');
                isInTuple = false;
              }
              isBroken = true;
              break;
            }
            if (tokens[j].text === '(') {
              parenthesesCount--;
            } else if (tokens[j].text === ')') {
              parenthesesCount++;
            }
          }
        }
        if (isBroken === false) {
          if (converted[initialConvertedLength] === 'async') {
            shiftSpaceIndexes(initialConvertedLength + 2);
            converted.splice(initialConvertedLength + 1, 0, '(');
          } else {
            shiftSpaceIndexes(initialConvertedLength);
            converted.splice(initialConvertedLength, 0, '(');
          }
          lastBoundaryIndex = initialConvertedLength;
          lastBoundaryToken = initialBoundaryToken;

          if (isInTuple !== false) {
            if (converted[converted.length - 1] === ',') {
              converted.pop();
            }
            converted.push(')');
            isInTuple = false;
          }
        }

        converted.push(')', '=>');
        spaceIndexes.add(converted.length - 1);

        const next = isNext(token => token.text === '{', true, i, tokens, false, true) as { result: boolean, index: number };
        if (next.result) {
          spaceIndexes.add(converted.length);
          converted.push('{\r\n');
          let braceCount = 1;
          let endBraceIndex = -1;
          for (let j = next.index + 1; j < tokens.length; j++) {
            if (tokens[j].text === '{') {
              braceCount++;
            } else if (tokens[j].text === '}') {
              braceCount--;
              if (braceCount === 0) {
                endBraceIndex = j;
                break;
              }
            }
          }
          if (endBraceIndex === -1)
            throw new SyntaxError(tokens[i], 'Missing right brace');
          convertBlock(tokens.slice(next.index + 1, endBraceIndex), 'fn', indentLevel + 1, false, false);
          converted.push(' '.repeat(indentLevel * indentCount));
          converted.push('}');
          i = endBraceIndex;
        }
      } else if (current.text === 'fn' && current.category === 'keyword' && isNext(token => token.text === ':' || token.text === '?', true, i, tokens, false, false) === true) {
        isConst = false;
        let nullable = false;
        if (tokens.length > i + 1 && tokens[i + 1].text === '?') {
          nullable = true;
          i++;
        }
        const nextToFn = isNext(token => token.text === ':', true, i, tokens, true) as { result: boolean, item: BaseToken | null };
        if (nextToFn.result && nextToFn.item) {
          const nextToFnIndex = tokens.indexOf(nextToFn.item);
          if (nextToFnIndex === -1) {
            throw new UnhandledError(tokens[i]);
          }
          const removed = removeEmptyWords(tokens.slice(nextToFnIndex + 1));
          const fnType = parseFunctionType(removed, false, false, false, true);
          if (nullable)
            fnType.type.nullable = true;
          converted.push(convertType(fnType.type, false, false));
          const endTokenIndex = tokens.indexOf(removed[fnType.endAt - 1]);
          if (endTokenIndex === -1) {
            throw new UnhandledError(removed[fnType.endAt - 1]);
          }
          decorations.push({ start: removed[0].start, end: removed[fnType.endAt - 1].end, kind: 'fn-type' });
          i = endTokenIndex;
        } else {
          throw new SyntaxError(current);
        }
      } else if (current.text === ':' && isTernaryOperator === false) {
        isConst = false;
        const removed = removeEmptyWords(tokens.slice(i + 1));
        const type = parseType(removed, false, true, false);
        if (type.type === null || type.endAt === 0)
          throw new SyntaxError(removed[0], 'Missing type');
        converted.splice(converted.length - 1, 0, convertType(type.type, false, false));
        spaceIndexes.add(converted.length - 1);
        i = tokens.findIndex(token => token.tokenId === removed[type.endAt - 1].tokenId);
      } else if (isAfterFn === 0 && ((current.category !== 'operator' && current.kind !== 'keyword.operator') || current.text === '{' || current.text === '}' || current.text === '(' || current.text === ')')) {
        return afterFnIndex;
      } else if (current.text === 'async') {
        converted.push('async');
        lastBoundaryIndex = converted.length;
        lastBoundaryToken = null;
        setLastBoundaryTokenNext = true;
        spaceIndexes.add(converted.length);
        isAsync = true;
      } else if (current.text === 'switch') {
        let braceCount = 0;
        let endBraceIndex = -1;
        for (let j = i + 1; j < tokens.length; j++) {
          if (tokens[j].text === '{') {
            braceCount++;
          } else if (tokens[j].text === '}') {
            braceCount--;
            if (braceCount === 0) {
              endBraceIndex = j;
              break;
            }
          }
        }
        if (endBraceIndex === -1)
          throw new SyntaxError(tokens[i], 'Missing right brace');

        const inserted = convertSwitch(tokens.slice(i, endBraceIndex + 1), isInArgs ? -1 : insertIndex, isInArgs ? true : assigningType, shouldStatic, indentLevel, false);
        if (inserted !== false) {
          if (insertedAutoGeneratedFn === false)
            insertedAutoGeneratedFn = [];
          insertedAutoGeneratedFn.push(...inserted);
        }
        i = endBraceIndex;
      } else if (current.text === 'with') {
        const nextIndex = isNext(token => token.text === '{', true, i, tokens, false, true) as { result: boolean, index: number };
        if (nextIndex.result === false)
          throw new SyntaxError(current, 'Missing left brace after with');
        converted.push('with {');
        i = nextIndex.index + 1;
        while (true) {
          if (tokens[i].text === '}') {
            converted.push('}');
            break;
          } else if (tokens[i].category === 'space' || tokens[i].category === 'line_break' || tokens[i].category === 'comment') {
            i++;
            continue;
          } else {
            if (tokens[i].category !== undefined && tokens[i].category !== 'context_keyword')
              throw new SyntaxError(tokens[i]);

            spaceIndexes.add(converted.length);
            converted.push(tokens[i].text);
            const equalIndex = isNext(token => token.text === '=', true, i, tokens, false, true) as { result: boolean, index: number };
            if (equalIndex.result === false)
              throw new SyntaxError(tokens[i], 'Missing equal operator');
            converted.push(' = ');
            i = equalIndex.index;
            const endAt = convertRightSide(tokens.slice(equalIndex.index + 1), insertIndex, true, false, indentLevel);
            i += endAt.endAt + 1;

            if (converted[converted.length - 1] === ';\r\n')
              converted.pop();
            if (converted[converted.length - 1] === ' ')
              converted.pop();

            let next = isNext(token => token.text === ',', true, i, tokens, false, true) as { result: boolean, index: number };
            if (next.result)
              i = next.index;
            else
              converted.push(',');

            i++;
          }
        }
      } else {
        if (current.category === undefined || current.category === 'keyword' || current.category === 'context_keyword') {
          changeKind(current, 'name.other');
          isConst = false;
        } else if (current.category !== 'operator' || current.text === 'true' || current.text === 'false' || current.text === 'null')
          currentMethod = true;
        else if (current.text === '?')
          isTernaryOperator = true;

        if (current.kind === 'literal.string' || current.kind === 'literal.char')
          converted.push(current.data!);
        else
          converted.push(current.text);

        if (previousIsSpace)
          spaceIndexes.add(converted.length - 1);
      }

      if (withSpacesOperators.has(converted[converted.length - 1])) {
        spaceIndexes.add(converted.length - 1);
        spaceIndexes.add(converted.length);
      }
      else if (noLeftSpacesRightSpaceOperators.has(converted[converted.length - 1])) {
        spaceIndexes.add(converted.length);
      } else if (leftSpaceNoRightSpacesOperators.has(converted[converted.length - 1])) {
        spaceIndexes.add(converted.length - 1);
      }
    }

    if (isInTuple !== false) {
      if (converted[converted.length - 1] === ',') {
        converted.pop();
      }
      converted.push(')');
    }

    lastBoundaryIndex = converted.length;
    lastBoundaryToken = null;
    setLastBoundaryTokenNext = true;
    return tokens.length;
  }

  function shiftSpaceIndexes(start: number, shift = 1) {
    const spaceIndexesArray = Array.from(spaceIndexes);
    spaceIndexesArray.sort((a, b) => a - b);
    if (shift > 0) {
      for (let i = spaceIndexesArray.length - 1; i >= 0; i--) {
        const index = spaceIndexesArray[i];
        if (index >= start) {
          spaceIndexes.delete(index);
          spaceIndexes.add(index + shift);
        }
      }
    } else {
      for (let i = 0; i < spaceIndexesArray.length; i++) {
        const index = spaceIndexesArray[i];
        if (index >= start) {
          spaceIndexes.delete(index);
          spaceIndexes.add(index + shift);
        }
      }
    }
  }
}
